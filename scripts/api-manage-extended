#!/bin/bash

# Extended API Management Script
# Includes deployment management capabilities

set -e

# Configuration
CONFIG_FILE="/etc/api-gateway/apis.json"
SCRIPT_DIR="/opt/api-gateway/scripts"
MODULE_DIR="/opt/api-gateway/modules"

# Source modules
source "$MODULE_DIR/common.sh"
source "$MODULE_DIR/deployment-manager.sh"
source "$MODULE_DIR/webhook-handler.sh"

# Help function
show_help() {
    cat << 'EOF'
API Gateway Extended Management Tool

USAGE:
    api-manage-extended <command> [options]

API MANAGEMENT:
    add <name> <port> [path]         Add new API service
    remove <name>                    Remove API service
    list                            List all API services
    enable <name>                   Enable API service
    disable <name>                  Disable API service
    reload                          Reload nginx configuration

DEPLOYMENT MANAGEMENT:
    deploy setup-private            Wizard: set up SSH key for private GitHub repos
    deploy add <name> <repo> [branch] <port> [build_cmd] [start_cmd]
                                    Add deployment (auto nginx; .nvmrc = Node version)
    deploy remove <name>            Remove deployment
    deploy list                     List all deployments
    deploy status [name]            Show deployment status
    deploy run <name>               Deploy/redeploy service
    deploy logs <name>              Show deployment logs

WEBHOOK MANAGEMENT:
    webhook start                   Start webhook server
    webhook stop                    Stop webhook server
    webhook status                  Show webhook server status
    webhook url <name>              Get webhook URL for service
    webhook setup <name>            Show GitHub webhook setup instructions

DASHBOARD MANAGEMENT:
    dashboard start                 Start web dashboard
    dashboard stop                  Stop web dashboard
    dashboard status                Show dashboard status
    dashboard url                   Get dashboard URL

AI MODEL MANAGEMENT:
    ai add ollama [path]            Install Ollama and register in gateway
    ai add localai [path]           Install LocalAI via Docker
    ai add vllm [path]              Install vLLM (requires GPU)
    ai list                         List registered AI services
    ai remove <name>                Remove AI service
    ai pull <model>                 Pull model (Ollama: ollama pull <model>)

SYSTEM MANAGEMENT:
    status                          Show overall system status
    logs [service]                  Show system logs
    backup                          Create configuration backup
    restore <backup_file>           Restore from backup

EXAMPLES:
    # Add API service
    api-manage-extended add my-api 3000

    # Add deployment with auto-deploy
    api-manage-extended deploy add my-app https://github.com/user/repo main 3000

    # Start webhook server for auto-deployment
    api-manage-extended webhook start

    # Start web dashboard
    api-manage-extended dashboard start

    # Show system status
    api-manage-extended status

    # Install Ollama AI and expose at /ai/ollama
    api-manage-extended ai add ollama

    # Pull a model
    api-manage-extended ai pull llama3

EOF
}

# API Management Functions
api_add() {
    local name="$1"
    local port="$2"
    local path="${3:-/$name}"
    
    if [ -z "$name" ] || [ -z "$port" ]; then
        print_error "Usage: add <name> <port> [path]"
        return 1
    fi
    
    # Use original api-manage script
    /opt/api-gateway/scripts/api-manage add "$name" "$port" "$path"
}

api_remove() {
    local name="$1"
    
    if [ -z "$name" ]; then
        print_error "Usage: remove <name>"
        return 1
    fi
    
    /opt/api-gateway/scripts/api-manage remove "$name"
}

api_list() {
    /opt/api-gateway/scripts/api-manage list
}

api_enable() {
    local name="$1"
    
    if [ -z "$name" ]; then
        print_error "Usage: enable <name>"
        return 1
    fi
    
    /opt/api-gateway/scripts/api-manage enable "$name"
}

api_disable() {
    local name="$1"
    
    if [ -z "$name" ]; then
        print_error "Usage: disable <name>"
        return 1
    fi
    
    /opt/api-gateway/scripts/api-manage disable "$name"
}

api_reload() {
    /opt/api-gateway/scripts/api-manage reload
}

# Dashboard Management Functions
dashboard_start() {
    print_header "Starting Web Dashboard"
    
    # Install Node.js if needed
    if ! command_exists node; then
        print_info "Installing Node.js..."
        curl -fsSL https://deb.nodesource.com/setup_22.x | bash -
        safe_apt install nodejs
    fi
    
    # Install npm dependencies
    if [ -f "/opt/api-gateway/web-ui/package.json" ]; then
        print_info "Installing npm dependencies..."
        cd /opt/api-gateway/web-ui
        npm install --production --silent
    fi
    
    # Create systemd service for dashboard
    cat > /etc/systemd/system/api-gateway-dashboard.service << 'EOF'
[Unit]
Description=API Gateway Web Dashboard
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/api-gateway/web-ui
ExecStart=/usr/bin/node server.js
Restart=always
RestartSec=10
Environment=NODE_ENV=production

# Logging
StandardOutput=append:/var/log/api-gateway/dashboard.log
StandardError=append:/var/log/api-gateway/dashboard.log

[Install]
WantedBy=multi-user.target
EOF

    # Web UI files are installed by install.sh; no copy here to avoid same-file errors
    if [ ! -f /opt/api-gateway/web-ui/server.js ]; then
        print_error "Dashboard not found. Run the full install first: sudo ./install.sh"
        return 1
    fi
    chmod +x /opt/api-gateway/web-ui/server.js
    chmod +x /opt/api-gateway/web-ui/webhook-server.js
    
    # Start service
    systemctl daemon-reload
    systemctl enable api-gateway-dashboard
    systemctl start api-gateway-dashboard
    
    if service_is_running "api-gateway-dashboard"; then
        print_success "Web dashboard started"
        local server_ip=$(curl -s ifconfig.me 2>/dev/null || echo "localhost")
        print_info "Dashboard URL: http://${server_ip}:8080"
    else
        print_error "Failed to start web dashboard"
        return 1
    fi
}

dashboard_stop() {
    print_header "Stopping Web Dashboard"
    
    if service_is_running "api-gateway-dashboard"; then
        systemctl stop api-gateway-dashboard
        systemctl disable api-gateway-dashboard
        print_success "Web dashboard stopped"
    else
        print_info "Web dashboard is not running"
    fi
}

dashboard_status() {
    print_header "Web Dashboard Status"
    
    if service_is_running "api-gateway-dashboard"; then
        print_success "Dashboard is running"
        local server_ip=$(curl -s ifconfig.me 2>/dev/null || echo "localhost")
        print_info "Dashboard URL: http://${server_ip}:8080"
    else
        print_error "Dashboard is not running"
    fi
}

dashboard_url() {
    local server_ip=$(curl -s ifconfig.me 2>/dev/null || echo "localhost")
    echo "http://${server_ip}:8080"
}

# System status overview
show_system_status() {
    print_header "API Gateway System Status"
    
    echo "=== Services ==="
    echo "Nginx: $(get_service_status nginx)"
    echo "OpenObserve: $(get_service_status openobserve)"
    echo "Fluent Bit: $(get_service_status fluent-bit)"
    echo "Webhook Server: $(get_service_status api-gateway-webhook)"
    echo "Web Dashboard: $(get_service_status api-gateway-dashboard)"
    echo ""
    
    echo "=== API Services ==="
    if [ -f "$CONFIG_FILE" ]; then
        jq -r '.apis[] | select(.enabled == true) | "✓ \(.name) (port \(.port)) - \(.path)"' "$CONFIG_FILE" 2>/dev/null || echo "No enabled APIs"
    else
        echo "No API configuration found"
    fi
    echo ""
    
    echo "=== Deployments ==="
    if [ -d "$DEPLOY_CONFIG_DIR" ] && [ "$(ls -A "$DEPLOY_CONFIG_DIR" 2>/dev/null)" ]; then
        for config_file in "$DEPLOY_CONFIG_DIR"/*.json; do
            if [ -f "$config_file" ]; then
                local service_name=$(basename "$config_file" .json)
                local status=$(get_deployment_status "$service_name" | jq -r '.status // "unknown"')
                local system_status="Stopped"
                
                if service_is_running "$service_name"; then
                    system_status="Running"
                fi
                
                echo "• $service_name: $status ($system_status)"
            fi
        done
    else
        echo "No deployments configured"
    fi
    echo ""
    
    echo "=== System Resources ==="
    echo "Load Average: $(cat /proc/loadavg | cut -d' ' -f1-3)"
    echo "Memory Usage: $(free -h | awk '/^Mem:/ {printf "%s/%s (%.1f%%)", $3, $2, ($3/$2)*100}')"
    echo "Disk Usage: $(df -h / | awk 'NR==2 {printf "%s/%s (%s)", $3, $2, $5}')"
    echo "Uptime: $(uptime -p)"
}

# Show logs
show_logs() {
    local service="$1"
    
    if [ -n "$service" ]; then
        print_header "Logs for $service"
        journalctl -u "$service" --no-pager -n 50
    else
        print_header "System Logs"
        echo "Available log files:"
        echo "• System: /var/log/api-gateway/system.log"
        echo "• Webhook: /var/log/api-gateway/webhook.log"
        echo "• Dashboard: /var/log/api-gateway/dashboard.log"
        echo "• Deployments: /var/log/api-gateway/deployments/"
        echo ""
        echo "Recent system events:"
        journalctl --no-pager -n 20
    fi
}

# Backup configuration
backup_config() {
    local backup_dir="/var/backups/api-gateway"
    local backup_file="$backup_dir/backup-$(date +%Y%m%d-%H%M%S).tar.gz"
    
    print_header "Creating Configuration Backup"
    
    mkdir -p "$backup_dir"
    
    # Create backup
    tar -czf "$backup_file" \
        -C / \
        etc/api-gateway \
        etc/nginx/sites-available/apis \
        var/lib/api-gateway \
        opt/openobserve/.credentials 2>/dev/null || true
    
    if [ -f "$backup_file" ]; then
        print_success "Backup created: $backup_file"
        print_info "Backup size: $(du -h "$backup_file" | cut -f1)"
    else
        print_error "Failed to create backup"
        return 1
    fi
}

# Restore configuration
restore_config() {
    local backup_file="$1"
    
    if [ -z "$backup_file" ] || [ ! -f "$backup_file" ]; then
        print_error "Usage: restore <backup_file>"
        print_info "Available backups:"
        ls -la /var/backups/api-gateway/*.tar.gz 2>/dev/null || echo "No backups found"
        return 1
    fi
    
    print_header "Restoring Configuration"
    print_warning "This will overwrite current configuration!"
    
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Restore cancelled"
        return 0
    fi
    
    # Extract backup
    tar -xzf "$backup_file" -C /
    
    if [ $? -eq 0 ]; then
        print_success "Configuration restored from $backup_file"
        print_info "Reloading services..."
        
        # Reload services
        systemctl reload nginx
        systemctl restart api-gateway-webhook 2>/dev/null || true
        systemctl restart api-gateway-dashboard 2>/dev/null || true
        
        print_success "Services reloaded"
    else
        print_error "Failed to restore configuration"
        return 1
    fi
}

# Wizard: set up SSH key for private GitHub repos
deploy_setup_private() {
    print_header "Setup for private GitHub repositories"
    
    echo -e "${CYAN}Server or service name (e.g. bar-connect-prod, orange-pi):${NC}"
    read -r -p "Name: " key_name
    key_name=$(echo "$key_name" | tr ' ' '_' | tr -cd '[:alnum:]_-' | head -c 64)
    if [ -z "$key_name" ]; then
        print_error "Name cannot be empty"
        return 1
    fi
    
    local ssh_dir="/root/.ssh"
    local key_file="$ssh_dir/id_ed25519_${key_name}"
    local key_pub="${key_file}.pub"
    
    mkdir -p "$ssh_dir"
    chmod 700 "$ssh_dir"
    
    rm -f "$key_file" "$key_pub"
    print_info "Generating new SSH key (no passphrase, for non-interactive deploy)..."
    ssh-keygen -t ed25519 -C "api-gateway-deploy-${key_name}" -f "$key_file" -N ""
    if [ ! -f "$key_file" ]; then
        print_error "Failed to create SSH key"
        return 1
    fi
    chmod 600 "$key_file"
    chmod 644 "$key_pub"
    print_success "SSH key created: $key_file"
    echo ""
    print_info "Your public key (copy and add to GitHub):"
    echo ""
    echo -e "${CYAN}----------------------------------------${NC}"
    cat "$key_pub"
    echo -e "${CYAN}----------------------------------------${NC}"
    
    local config_file="$ssh_dir/config"
    local config_tmp="${config_file}.tmp.$$"
    if [ -f "$config_file" ]; then
        awk '
            /^Host[ \t]/ {
                if (in_github) in_github = 0;
                if ($2 == "github.com") in_github = 1;
                if (!in_github) print;
                next;
            }
            !in_github { print }
        ' "$config_file" > "$config_tmp"
    else
        true > "$config_tmp"
    fi
    cat >> "$config_tmp" << EOF

Host github.com
    IdentityFile $key_file
    StrictHostKeyChecking accept-new
EOF
    mv "$config_tmp" "$config_file"
    chmod 600 "$config_file"
    print_success "SSH config updated for github.com"
    
    echo ""
    echo -e "${YELLOW}What to do in GitHub:${NC}"
    echo "  1. Open your repository on GitHub"
    echo "  2. Go to: Settings → Deploy keys"
    echo "  3. Click \"Add deploy key\""
    echo "  4. Title: $key_name (or use this name so you know which server)"
    echo "  5. Key: paste the line above (the whole line from ssh-ed25519 to the end)"
    echo "  6. Leave \"Allow write access\" unchecked (read is enough for deploy)"
    echo "  7. Click \"Add key\""
    echo ""
    echo -e "${YELLOW}Then add the deployment (use SSH URL, not HTTPS):${NC}"
    echo "  On this server run:"
    echo ""
    echo -e "  ${GREEN}api-manage-extended deploy add <name> git@github.com:USERNAME/REPO.git main <port>${NC}"
    echo ""
    echo "  Replace: <name> = service name, USERNAME = your GitHub user/org, REPO = repo name, <port> = app port (e.g. 3000)"
    echo ""
    echo -e "${YELLOW}Get the SSH URL in GitHub:${NC} repo → green \"Code\" button → tab \"SSH\" → copy"
    echo ""
}

# AI Model Management Functions
ai_register_service() {
    local name="$1"
    local port="$2"
    local ai_path="${3:-/ai/$name}"
    
    local config_file="/etc/api-gateway/apis.json"
    if jq -e ".apis[] | select(.name == \"$name\")" "$config_file" &>/dev/null; then
        print_info "Route for $name already exists, updating..."
        jq --arg n "$name" --argjson p "$port" \
            '.apis |= map(if .name == $n then .port = $p else . end)' \
            "$config_file" > "${config_file}.tmp" && mv "${config_file}.tmp" "$config_file"
    else
        jq --arg n "$name" --arg path "$ai_path" --argjson p "$port" \
            '.apis += [{"name": $n, "path": $path, "port": $p, "description": "AI Model Service", "enabled": true, "type": "ai-model", "streaming": true, "websocket": false, "timeout": 600, "max_body_size": "1g", "fix_redirects": false}]' \
            "$config_file" > "${config_file}.tmp" && mv "${config_file}.tmp" "$config_file"
        print_success "Route added: ${ai_path}/ -> localhost:${port}"
    fi
    
    [ -x /usr/local/bin/generate-nginx-config ] && /usr/local/bin/generate-nginx-config 2>/dev/null && print_info "Nginx config regenerated" || true
    [ -x /usr/local/bin/generate-fluentbit-config ] && /usr/local/bin/generate-fluentbit-config 2>/dev/null || true
}

ai_add() {
    local ai_type="$1"
    local ai_path="${2:-}"
    
    case "$ai_type" in
        ollama)
            print_header "Installing Ollama"
            ai_path="${ai_path:-/ai/ollama}"
            
            if command_exists ollama; then
                print_success "Ollama already installed"
            else
                print_info "Downloading Ollama..."
                curl -fsSL https://ollama.com/install.sh | sh
                if command_exists ollama; then
                    print_success "Ollama installed"
                else
                    print_error "Failed to install Ollama"
                    return 1
                fi
            fi
            
            # Enable and start Ollama service
            systemctl enable ollama 2>/dev/null || true
            systemctl start ollama 2>/dev/null || true
            sleep 2
            
            if service_is_running "ollama"; then
                print_success "Ollama service is running"
            else
                print_warning "Ollama service not running, trying to start..."
                systemctl restart ollama 2>/dev/null || true
            fi
            
            ai_register_service "ollama" 11434 "$ai_path"
            
            print_success "Ollama registered at ${ai_path}/"
            print_info "Pull a model: api-manage-extended ai pull llama3"
            print_info "API endpoint: http://<server_ip>:<port>${ai_path}/api/generate"
            ;;
        
        localai)
            print_header "Installing LocalAI (Docker)"
            ai_path="${ai_path:-/ai/localai}"
            
            if ! command_exists docker; then
                print_error "Docker is required for LocalAI"
                print_info "Install Docker: curl -fsSL https://get.docker.com | sh"
                return 1
            fi
            
            # Stop existing if running
            docker stop localai 2>/dev/null || true
            docker rm localai 2>/dev/null || true
            
            print_info "Starting LocalAI container..."
            mkdir -p /opt/ai-models/localai
            docker run -d --restart unless-stopped \
                --name localai \
                -p 8181:8080 \
                -v /opt/ai-models/localai:/models \
                localai/localai:latest
            
            sleep 5
            if docker ps --format '{{.Names}}' | grep -q "^localai$"; then
                print_success "LocalAI container is running"
            else
                print_error "Failed to start LocalAI"
                return 1
            fi
            
            ai_register_service "localai" 8181 "$ai_path"
            
            print_success "LocalAI registered at ${ai_path}/"
            print_info "API endpoint: http://<server_ip>:<port>${ai_path}/v1/chat/completions"
            ;;
        
        vllm)
            print_header "Installing vLLM"
            ai_path="${ai_path:-/ai/vllm}"
            
            if ! command_exists python3; then
                print_error "Python3 is required for vLLM"
                return 1
            fi
            
            print_info "Installing vLLM (this may take a while)..."
            pip3 install vllm 2>/dev/null || {
                print_error "Failed to install vLLM"
                print_info "vLLM requires a CUDA-capable GPU"
                return 1
            }
            
            ai_register_service "vllm" 8000 "$ai_path"
            
            print_success "vLLM registered at ${ai_path}/"
            print_info "Start vLLM: vllm serve <model_name> --port 8000"
            print_info "API endpoint: http://<server_ip>:<port>${ai_path}/v1/completions"
            ;;
        
        *)
            print_error "Unknown AI type: $ai_type"
            echo "Supported: ollama, localai, vllm"
            return 1
            ;;
    esac
}

ai_list() {
    print_header "AI Model Services"
    
    local config_file="/etc/api-gateway/apis.json"
    local count=$(jq '[.apis[] | select(.type == "ai-model")] | length' "$config_file" 2>/dev/null)
    
    if [ "$count" = "0" ] || [ -z "$count" ]; then
        print_info "No AI services registered"
        echo "  Add one: api-manage-extended ai add ollama"
        return
    fi
    
    jq -r '.apis[] | select(.type == "ai-model") | "  \(.name) -> \(.path) (port \(.port)) [\(if .enabled then "ACTIVE" else "DISABLED" end)]"' "$config_file"
}

ai_remove() {
    local name="$1"
    
    if [ -z "$name" ]; then
        print_error "Usage: ai remove <name>"
        return 1
    fi
    
    print_header "Removing AI service: $name"
    
    # Stop services
    case "$name" in
        ollama)
            systemctl stop ollama 2>/dev/null || true
            systemctl disable ollama 2>/dev/null || true
            ;;
        localai)
            docker stop localai 2>/dev/null || true
            docker rm localai 2>/dev/null || true
            ;;
    esac
    
    # Remove from apis.json
    local config_file="/etc/api-gateway/apis.json"
    jq --arg n "$name" '.apis |= map(select(.name != $n))' "$config_file" > "${config_file}.tmp" && mv "${config_file}.tmp" "$config_file"
    
    [ -x /usr/local/bin/generate-nginx-config ] && /usr/local/bin/generate-nginx-config 2>/dev/null || true
    [ -x /usr/local/bin/generate-fluentbit-config ] && /usr/local/bin/generate-fluentbit-config 2>/dev/null || true
    
    print_success "AI service $name removed"
}

ai_pull() {
    local model="$1"
    
    if [ -z "$model" ]; then
        print_error "Usage: ai pull <model>"
        echo "  Examples: llama3, codellama, mistral, phi3, gemma"
        return 1
    fi
    
    if command_exists ollama; then
        print_info "Pulling model: $model (this may take a while)..."
        ollama pull "$model"
        print_success "Model $model pulled"
    else
        print_error "Ollama is not installed"
        print_info "Install: api-manage-extended ai add ollama"
        return 1
    fi
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        show_help
        return 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        # API Management
        "add")
            api_add "$@"
            ;;
        "remove")
            api_remove "$@"
            ;;
        "list")
            api_list "$@"
            ;;
        "enable")
            api_enable "$@"
            ;;
        "disable")
            api_disable "$@"
            ;;
        "reload")
            api_reload "$@"
            ;;
        
        # Deployment Management
        "deploy")
            local deploy_cmd="$1"
            shift
            case "$deploy_cmd" in
                "setup-private")
                    deploy_setup_private
                    ;;
                "add")
                    add_deployment "$@"
                    [ $? -eq 0 ] && show_webhook_instructions "$1"
                    ;;
                "remove")
                    remove_deployment "$@"
                    ;;
                "list")
                    list_deployments
                    ;;
                "status")
                    if [ -n "$1" ]; then
                        get_deployment_status "$1"
                    else
                        list_deployments
                    fi
                    ;;
                "run")
                    deploy_service "$@"
                    ;;
                "logs")
                    if [ -n "$1" ]; then
                        local log_file="/var/log/api-gateway/deployments/${1}-*.log"
                        if ls $log_file 1> /dev/null 2>&1; then
                            tail -f $(ls -t $log_file | head -1)
                        else
                            print_error "No deployment logs found for $1"
                        fi
                    else
                        print_error "Service name required"
                    fi
                    ;;
                *)
                    print_error "Unknown deploy command: $deploy_cmd"
                    show_help
                    return 1
                    ;;
            esac
            ;;
        
        # Webhook Management
        "webhook")
            local webhook_cmd="$1"
            shift
            case "$webhook_cmd" in
                "start")
                    start_webhook_server
                    ;;
                "stop")
                    stop_webhook_server
                    ;;
                "status")
                    if is_webhook_running; then
                        if [ -f "$WEBHOOK_PID_FILE" ] && kill -0 "$(cat "$WEBHOOK_PID_FILE")" 2>/dev/null; then
                            print_success "Webhook server is running (PID: $(cat "$WEBHOOK_PID_FILE"))"
                        elif systemctl is-active --quiet api-gateway-webhook 2>/dev/null; then
                            print_success "Webhook server is running (systemd)"
                        else
                            print_success "Webhook server is running (port $WEBHOOK_PORT)"
                        fi
                        print_info "Port: $WEBHOOK_PORT"
                    else
                        print_error "Webhook server is not running"
                    fi
                    ;;
                "url")
                    if [ -n "$1" ]; then
                        get_webhook_url "$1"
                    else
                        print_error "Service name required"
                    fi
                    ;;
                "setup")
                    if [ -n "$1" ]; then
                        show_webhook_instructions "$1"
                    else
                        print_error "Service name required"
                    fi
                    ;;
                *)
                    print_error "Unknown webhook command: $webhook_cmd"
                    show_help
                    return 1
                    ;;
            esac
            ;;
        
        # AI Model Management
        "ai")
            local ai_cmd="$1"
            shift
            case "$ai_cmd" in
                "add")
                    ai_add "$@"
                    ;;
                "list")
                    ai_list
                    ;;
                "remove")
                    ai_remove "$@"
                    ;;
                "pull")
                    ai_pull "$@"
                    ;;
                *)
                    print_error "Unknown ai command: $ai_cmd"
                    show_help
                    return 1
                    ;;
            esac
            ;;
        
        # Dashboard Management
        "dashboard")
            local dashboard_cmd="$1"
            shift
            case "$dashboard_cmd" in
                "start")
                    dashboard_start
                    ;;
                "stop")
                    dashboard_stop
                    ;;
                "status")
                    dashboard_status
                    ;;
                "url")
                    dashboard_url
                    ;;
                *)
                    print_error "Unknown dashboard command: $dashboard_cmd"
                    show_help
                    return 1
                    ;;
            esac
            ;;
        
        # System Management
        "status")
            show_system_status
            ;;
        "logs")
            show_logs "$1"
            ;;
        "backup")
            backup_config
            ;;
        "restore")
            restore_config "$1"
            ;;
        
        # Help
        "help"|"-h"|"--help")
            show_help
            ;;
        
        *)
            print_error "Unknown command: $command"
            show_help
            return 1
            ;;
    esac
}

# Check if running as root
check_sudo

# Initialize deployment manager if not already done
if [ ! -d "$DEPLOY_CONFIG_DIR" ]; then
    init_deployment_manager
fi

# Run main function
main "$@"